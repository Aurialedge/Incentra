from ml_model_module import predict_with_error
from utils import (   
    percentile_rank, get_tier, apply_fairness,
    compute_days, detailed_activity_analysis,
    ROLE_FEATURE_WEIGHTS, ROLE_BOOSTS
)
from initial_boosts import get_boost_for_user
from hybridspamdetector import HybridSpamDetector
import pandas as pd
import numpy as np
# Single instance of spam detector
spam_detector = HybridSpamDetector()

def compute_level_score_backend(user_profile, population_samples, month_active, history_scores=[]):
    role = user_profile.get("role", "driver")
    features = user_profile.get("features", {})

    # ---------------- Role-specific features ----------------
    if role == "driver":
        features_list = [
            features.get("login_rate", 0),
            features.get("streak_days", 0),
            features.get("rides_30d", 0),
            features.get("on_time_rate", 0),
            features.get("cancellation_rate", 0),
            features.get("rating", 0),
            features.get("avg_ride_distance", 0),
            features.get("peak_hour_rides", 0),
            features.get("late_pickup_rate", 0),
            features.get("customer_complaints", 0),
            features.get("ratings_std", 0),
            features.get("total_hours_worked", 0)
        ]
    elif role == "merchant":
        features_list = [
            features.get("login_rate", 0),
            features.get("streak_days", 0),
            features.get("sales_30d", 0),
            features.get("order_fulfillment_rate", 0),
            features.get("return_rate", 0),
            features.get("rating", 0),
            features.get("avg_order_value", 0),
            features.get("peak_hour_sales", 0),
            features.get("complaints_received", 0),
            features.get("new_customers_acquired", 0),
            features.get("repeat_customer_rate", 0),
            features.get("total_hours_operated", 0)
        ]
    elif role == "delivery_partner":
        features_list = [
            features.get("login_rate", 0),
            features.get("streak_days", 0),
            features.get("deliveries_30d", 0),
            features.get("on_time_delivery_rate", 0),
            features.get("cancellation_rate", 0),
            features.get("rating", 0),
            features.get("avg_delivery_distance", 0),
            features.get("peak_hour_deliveries", 0),
            features.get("late_delivery_rate", 0),
            features.get("customer_complaints", 0),
            features.get("ratings_std", 0),
            features.get("total_hours_worked", 0)
        ]
    else:
        features_list = [features.get(k, 0) for k in features]

    # ---------------- Weighted features ----------------
    weights = ROLE_FEATURE_WEIGHTS.get(role, [1]*len(features_list))
    weighted_features = [f*w for f, w in zip(features_list, weights)]
    weighted_features = np.array(weighted_features,dtype=float).flatten()
    # ---------------- ML prediction ----------------
    R_raw, pred_error = predict_with_error(weighted_features)
    R_raw /= 1000
    percentile = percentile_rank(R_raw, population_samples.get("R_raw_values", []))
    base_gain = 1000 * percentile * 0.15
    gain = min(base_gain * (0.5 + 0.05 * month_active), 80)

    prev_score = history_scores[-1] if history_scores else 0
    trend_penalty = 0
    if len(history_scores) > 1 and (prev_score - history_scores[-2]) < -20:
        trend_penalty = 10
    initial_score = prev_score + gain - trend_penalty

    # ---------------- Activity analysis ----------------
    tier = get_tier(initial_score, role)
    activity_log = user_profile.get("activity_log", [])
    inconsistent_days, inactivity_days = compute_days(activity_log)
    avg_streak, max_streak = detailed_activity_analysis(activity_log)
    score_after, penalty, consistency_bonus = apply_fairness(initial_score, tier, inactivity_days, inconsistent_days)

    # ---------------- Initial Boost ----------------
    boost = get_boost_for_user(user_profile.get("user_id", 0))
    if month_active == 1 and user_profile.get("first_time_account", True):
        boost += ROLE_BOOSTS[role]["first_time"]
    if role == "driver" and features.get("rides_30d", 0) > 100:
        boost += ROLE_BOOSTS[role]["milestone_rides"]
    elif role == "merchant" and features.get("sales_30d", 0) > 100:
        boost += ROLE_BOOSTS[role]["high_sales"]
    elif role == "delivery_partner" and features.get("deliveries_30d", 0) > 100:
        boost += ROLE_BOOSTS[role]["milestone_deliveries"]

    # ---------------- Spam Detection ----------------
    # Ensure all required columns exist
    spam_defaults = {
        "review_count": 0,
        "rating_variance": 0,
        "avg_review_length": 0,
        "logins_per_day": 0,
        "std_login_time": 0,
        "account_age_days": 0
    }
    for k, v in spam_defaults.items():
        features.setdefault(k, v)

    spam_df = pd.DataFrame([features])
    spam_score_df = spam_detector.predict_hybrid_score(spam_df)
    spam_score = float(spam_score_df["spam_hybrid_score"].iloc[0])

    # ---------------- Final Score ----------------
    final_score = min(1000, score_after + boost)

    reason_log = (
        f"+{round(gain,2)} gain, -{penalty} penalty, +{consistency_bonus} consistency, "
        f"+{boost} boost, ±{pred_error} model error"
    )

    return {
        "final_score": round(final_score, 2),
        "tier": get_tier(final_score, role),
        "penalty": penalty,
        "consistency_bonus": consistency_bonus,
        "boost": boost,
        "inconsistent_days": inconsistent_days,
        "inactivity_days": inactivity_days,
        "avg_inactive_streak": avg_streak,
        "max_inactive_streak": max_streak,
        "ml_prediction_error_margin": pred_error,
        "spam_score": spam_score,
        "reason_log": reason_log
    }


import math
import numpy as np
import xgboost as xgb
from sklearn.metrics import mean_squared_error

# ---------------- Example Training Data ---------------- #
# Features for all roles (12 features per role)
X = np.array([
    [0.9,10,120,0.95,0.05,4.8,15.2,30,0.05,1,0.2,120],
    [0.7,5,60,0.88,0.1,4.5,12.0,15,0.1,3,0.4,80],
    [0.95,15,200,0.97,0.02,4.9,18.5,40,0.02,0,0.1,200],
    [0.5,3,30,0.85,0.15,4.3,10.0,8,0.15,5,0.5,50]
])
y = np.array([700, 400, 850, 250])

# ---------------- Train XGBoost Regressor ---------------- #
ml_model = xgb.XGBRegressor(
    n_estimators=200,
    max_depth=5,
    learning_rate=0.1,
    objective="reg:squarederror",
    random_state=42
)
ml_model.fit(X, y)

# ---------------- Error Calculation ---------------- #
train_preds = ml_model.predict(X)
rmse = math.sqrt(mean_squared_error(y, train_preds))
error_percent = (rmse / np.mean(y)) * 100

def predict_with_error(features, ml_model=ml_model, rmse=rmse):
    # print('features are here ',features)
    # features=np.array(features).flatten()
    # print('features are here modified ',features)
    arr = np.array(features,dtype=float).reshape(1,-1)
    print('features are here modified ',arr)
    pred = ml_model.predict(arr)[0]
    relative_error = rmse / np.max(y)
    margin = pred * relative_error
    print('the result is  ',pred,margin )
    return pred, round(margin,2)

__all__ = ["ml_model", "predict_with_error", "rmse", "error_percent"]

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any
import uvicorn
from level_score import compute_level_score_backend
from spam_detection import apply_spam_penalty
from initial_boosts import get_boost_for_user

app = FastAPI(title="Grab ML Service")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class UserFeatures(BaseModel):
    user_id: str
    role: str = "driver"
    features: Dict[str, Any]
    activity_log: List[Dict[str, Any]] = []
    history_scores: List[float] = []

class BoostRequest(BaseModel):
    user_id: str
    engagement_metrics: Dict[str, float]

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.post("/calculate-score")
async def calculate_score(user_data: UserFeatures):
    try:
        score_dict = compute_level_score_backend(
            user_profile={
                "user_id": user_data.user_id,
                "role": user_data.role,
                "features": user_data.features,
                "activity_log": user_data.activity_log
            },
            population_samples={"R_raw_values": []},  # Fetch from DB if needed
            month_active=30,
            history_scores=user_data.history_scores
        )

        # Apply spam penalty if hybrid score exceeds threshold
        final_score, credit_score = apply_spam_penalty(
            final_score=score_dict["final_score"],
            credit_score=score_dict["final_score"]*0.9,
            hybrid_score=score_dict["spam_score"]
        )

        score_dict.update({
            "user_id": user_data.user_id,
            "final_score": final_score,
            "credit_score": credit_score,
            "status": "success"
        })
        return score_dict

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/get-initial-boost")
async def get_initial_boost(request: BoostRequest):
    try:
        boost = get_boost_for_user(request.user_id)
        return {
            "user_id": request.user_id,
            "initial_boost": boost,
            "status": "success"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run("server:app", host="0.0.0.0", port=5000, reload=True)


import mongoose from 'mongoose';
import dotenv from 'dotenv';
import User from './Models/user.model.js';
import fetch from 'node-fetch';

dotenv.config();

// ---------------- MongoDB Connection ----------------
const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        console.log('MongoDB connected');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

// ---------------- List Users ----------------
async function listUsers() {
    try {
        const users = await User.find({}, 'email username role');
        console.log('Available users:');
        console.log(users);
        return users;
    } catch (error) {
        console.error('Error listing users:', error);
        return [];
    }
}

// ---------------- Test Level Score ----------------
const testLevelScore = async () => {
    try {
        await connectDB();
        
        // List available users
        const users = await listUsers();
        if (users.length === 0) {
            throw new Error('No users in database');
        }
        
        const testUser = users[0]; // pick first user
        console.log('Testing level score for user:', testUser.username);

        const currentDate = new Date();

        // ---------------- Prepare test payload ----------------
        const testData = {
            user_id: testUser._id.toString(),
            role: testUser.role || 'merchant',  // fallback
            features: {
                // Merchant default features
                login_rate: 0.9,
                streak_days: 30,
                sales_30d: 120,
                order_fulfillment_rate: 0.95,
                return_rate: 0.05,
                rating: 4.7,
                avg_order_value: 250.75,
                peak_hour_sales: 45,
                complaints_received: 2,
                new_customers_acquired: 25,
                repeat_customer_rate: 0.65,
                total_hours_operated: 300,
                first_time_account: false,

                // Spam detection features
                review_count: 50,
                rating_variance: 0.1,
                avg_review_length: 120,
                logins_per_day: 1.2,
                std_login_time: 0.3,
                account_age_days: 400,

                // --- Added to avoid KeyError ---
                active: 1
            },
            activity_log: [
                { event: 'login', timestamp: currentDate.toISOString(),active:true }
            ],
            history_scores: [78, 82, 80]  // previous months
        };

        console.log('Sending test data:', JSON.stringify(testData, null, 2));

        // ---------------- Call FastAPI ML service ----------------
        const response = await fetch('http://localhost:5000/calculate-score', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(testData)
        });
        // console.log('Response is here homie ', response);
        if (!response.ok) {
            const errorText = await response.text();
            console.error('ML Service Error:', {
                status: response.status,
                statusText: response.statusText,
                error: errorText
            });
            throw new Error(`ML Service request failed: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();

        if (result.status === 'success') {
            console.log('✅ Level score calculated successfully:');
            console.log('User ID:', result.user_id);
            console.log('Final Score:', result.final_score);
            console.log('Credit Score:', result.credit_score);
            console.log('Spam Score:', result.spam_score);
            console.log('Tier:', result.tier);
            console.log('Reason Log:', result.reason_log);
            console.log('Penalty:', result.penalty);
            console.log('Consistency Bonus:', result.consistency_bonus);
            console.log('Boost Applied:', result.boost);
        } else {
            console.error('❌ Failed to calculate level score:', result.message);
        }

    } catch (error) {
        console.error('Error in test:', error);
    } finally {
        process.exit(0);
    }
};

testLevelScore();
